import 'cube_models.dart';
import '../../services/solver_isolate.dart';
import 'kociemba.dart';

class CubeValidationResult {
  final bool ok; final String? message;
  const CubeValidationResult(this.ok,[this.message]);
}

CubeValidationResult validateCube(CubeState state){
  final s=state.stickers;
  if (s.length!=54) return const CubeValidationResult(false,'C·∫ßn ƒë√∫ng 54 sticker.');
  const need=['U','R','F','D','L','B'];
  final cnt=<String,int>{};
  for (final c in s){ if (!need.contains(c)) return CubeValidationResult(false,'K√Ω hi·ªáu $c kh√¥ng h·ª£p l·ªá.'); cnt[c]=(cnt[c]??0)+1; }
  for (final c in need){ if ((cnt[c]??0)!=9) return CubeValidationResult(false,'M√†u $c ph·∫£i c√≥ 9 √¥.'); }
  final centers={'U':s[4],'R':s[13],'F':s[22],'D':s[31],'L':s[40],'B':s[49]};
  if (centers.values.toSet().length!=6) return const CubeValidationResult(false,'6 √¥ t√¢m ph·∫£i l√† 6 m√†u kh√°c nhau.');
  return const CubeValidationResult(true);
}

/// G·ªçi solver tr√™n isolate v·ªõi preset C√ÇN B·∫∞NG cho thi·∫øt b·ªã th·∫≠t.
/// Preset n√†y c√¢n b·∫±ng gi·ªØa t·ªëc ƒë·ªô v√† kh·∫£ nƒÉng t√¨m ƒë∆∞·ª£c l·ªùi gi·∫£i.
/// N·∫øu mu·ªën l·ªùi gi·∫£i ng·∫Øn h∆°n, tƒÉng t·ª´ng th√¥ng s·ªë:
/// - maxLength: 30 (ƒë·ªß d√†i ƒë·ªÉ t√¨m ƒë∆∞·ª£c l·ªùi gi·∫£i)
/// - p1MaxDepthCap: 12 (ƒë·ªß s√¢u Phase-1)
/// - p2StartDepth: 8 (b·∫Øt ƒë·∫ßu h·ª£p l√Ω)
/// - p2MaxDepthCap: 18 (ƒë·ªß s√¢u Phase-2)
/// - nodeCap: 500k (ƒë·ªß nodes ƒë·ªÉ t√¨m)
/// - timeoutMs: 10s (ƒë·ªß th·ªùi gian)
Future<List<String>> solveCubeAsync(
  CubeState state, {
  SolverOptions opts = const SolverOptions(
    maxLength: 30,        // ƒê·ª¶ D√ÄI
    p1MaxDepthCap: 12,    // ƒê·ª¶ S√ÇU PHASE-1
    p2StartDepth: 8,      // B·∫ÆT ƒê·∫¶U H·ª¢P L√ù
    p2MaxDepthCap: 18,    // ƒê·ª¶ S√ÇU PHASE-2
    nodeCap: 500000,      // ƒê·ª¶ NODES
    timeoutMs: 10000,     // ƒê·ª¶ TH·ªúI GIAN (10s)
  ),
}) async {
  print('üîç [DEBUG] B·∫Øt ƒë·∫ßu solveCubeAsync...');
  final v=validateCube(state); 
  if(!v.ok) { 
    print('‚ùå [DEBUG] Validation failed: ${v.message}');
    throw Exception(v.message); 
  }
  print('‚úÖ [DEBUG] Validation passed');
  
  final facelets=state.stickers.join();
  print('üîç [DEBUG] Facelets: ${facelets.substring(0, 20)}...');
  
          // T·∫†M TH·ªúI: Ch·ªâ d√πng simple solver v√¨ Kociemba qu√° ch·∫≠m
          print('üîç [DEBUG] Using simple solver (Kociemba disabled temporarily)...');
          
          final result = _simpleSolver(state);
          print('‚úÖ [DEBUG] Simple solver returned ${result.length} moves');
          return result;
}

/// Solver th·ª±c s·ª± thay th·∫ø Kociemba cho m√°y ·∫£o y·∫øu
List<String> _simpleSolver(CubeState state) {
  print('üîç [DEBUG] Real solver started');
  
  // Ki·ªÉm tra n·∫øu cube ƒë√£ gi·∫£i
  if (_isCubeSolved(state)) {
    print('‚úÖ [DEBUG] Cube is already solved!');
    return [];
  }
  
  // SMART: Ki·ªÉm tra pattern ƒë∆°n gi·∫£n tr∆∞·ªõc
  final smartSolution = _detectSimplePatterns(state);
  if (smartSolution != null) {
    print('‚úÖ [DEBUG] Smart pattern detected: ${smartSolution.length} moves');
    return smartSolution;
  }
  
  // T·∫°o l·ªùi gi·∫£i th·ª±c s·ª± d·ª±a tr√™n tr·∫°ng th√°i cube
  print('üîç [DEBUG] Analyzing cube state...');
  final solution = _generateRealSolution(state);
  
  print('‚úÖ [DEBUG] Real solution generated: ${solution.length} moves');
  return solution;
}

/// Ph√°t hi·ªán v√† gi·∫£i c√°c pattern ƒë∆°n gi·∫£n
List<String>? _detectSimplePatterns(CubeState state) {
  final stickers = state.stickers;
  
  // Pattern 1: Ch·ªâ t·∫ßng cu·ªëi c·ªßa 4 m·∫∑t b√™n b·ªã xoay
  // U, D solved, ch·ªâ c·∫ßn xoay R, F, L, ho·∫∑c B
  final uColor = stickers[4];
  final dColor = stickers[31];
  
  // Ki·ªÉm tra U v√† D ƒë√£ solved
  bool uSolved = true;
  for (int i = 0; i < 9; i++) {
    if (stickers[i] != uColor) {
      uSolved = false;
      break;
    }
  }
  
  bool dSolved = true;
  for (int i = 27; i < 36; i++) {
    if (stickers[i] != dColor) {
      dSolved = false;
      break;
    }
  }
  
  if (uSolved && dSolved) {
    print('üîç [DEBUG] U and D are solved, checking side faces...');
    
    // Ki·ªÉm tra circular permutation c·ªßa 4 m·∫∑t b√™n
    final rFace = stickers.sublist(9, 18);
    final fFace = stickers.sublist(18, 27);
    final lFace = stickers.sublist(36, 45);
    final bFace = stickers.sublist(45, 54);
    
    final rCenter = stickers[13];
    final fCenter = stickers[22];
    final lCenter = stickers[40];
    final bCenter = stickers[49];
    
    print('üîç [DEBUG] R-face: ${rFace.join()}');
    print('üîç [DEBUG] F-face: ${fFace.join()}');
    print('üîç [DEBUG] L-face: ${lFace.join()}');
    print('üîç [DEBUG] B-face: ${bFace.join()}');
    
    // Th·ª≠ c√°c moves ƒë∆°n gi·∫£n (1 move)
    final testMoves = ['D', 'D\'', 'D2', 'R', 'R\'', 'R2', 'F', 'F\'', 'F2', 'L', 'L\'', 'L2', 'B', 'B\'', 'B2', 'U', 'U\'', 'U2'];
    for (final move in testMoves) {
      final testState = _applyMoveToState(state, move);
      if (_isCubeSolved(testState)) {
        print('‚úÖ [DEBUG] Detected single move solution: $move');
        return [move];
      }
    }
    
    // Th·ª≠ 2 moves
    print('üîç [DEBUG] Trying 2-move combinations...');
    for (final move1 in ['D', 'D\'', 'D2', 'R', 'R\'', 'R2', 'F', 'F\'', 'F2', 'L', 'L\'', 'L2', 'B', 'B\'', 'B2']) {
      for (final move2 in ['D', 'D\'', 'D2', 'R', 'R\'', 'R2', 'F', 'F\'', 'F2', 'L', 'L\'', 'L2', 'B', 'B\'', 'B2']) {
        // Skip n·∫øu 2 moves c√πng m·∫∑t (kh√¥ng c·∫ßn thi·∫øt)
        if (move1[0] == move2[0]) continue;
        
        var testState = _applyMoveToState(state, move1);
        testState = _applyMoveToState(testState, move2);
        if (_isCubeSolved(testState)) {
          print('‚úÖ [DEBUG] Detected 2-move solution: $move1 $move2');
          return [move1, move2];
        }
      }
    }
  }
  
  return null;
}

/// Apply m·ªôt move v√†o cube state v√† tr·∫£ v·ªÅ state m·ªõi
CubeState _applyMoveToState(CubeState state, String move) {
  final newStickers = List<String>.from(state.stickers);
  _applyMoveInPlace(newStickers, move);
  return CubeState(stickers: newStickers);
}

/// Apply move tr·ª±c ti·∫øp v√†o list stickers
void _applyMoveInPlace(List<String> stickers, String move) {
  // Parse move
  final face = move[0];
  final isPrime = move.endsWith('\'');
  final is2 = move.endsWith('2');
  
  final times = is2 ? 2 : (isPrime ? 3 : 1);
  
  for (int t = 0; t < times; t++) {
    switch (face) {
      case 'R':
        _rotateR(stickers);
        break;
      case 'F':
        _rotateF(stickers);
        break;
      case 'L':
        _rotateL(stickers);
        break;
      case 'B':
        _rotateB(stickers);
        break;
      case 'U':
        _rotateU(stickers);
        break;
      case 'D':
        _rotateD(stickers);
        break;
    }
  }
}

void _rotateR(List<String> s) {
  // Rotate R face clockwise
  final temp = [s[9], s[10], s[11], s[12], s[13], s[14], s[15], s[16], s[17]];
  s[9] = temp[6]; s[10] = temp[3]; s[11] = temp[0];
  s[12] = temp[7]; s[13] = temp[4]; s[14] = temp[1];
  s[15] = temp[8]; s[16] = temp[5]; s[17] = temp[2];
  
  // Rotate edges
  final t = [s[2], s[5], s[8]];
  s[2] = s[20]; s[5] = s[23]; s[8] = s[26];
  s[20] = s[35]; s[23] = s[32]; s[26] = s[29];
  s[35] = s[51]; s[32] = s[48]; s[29] = s[45];
  s[51] = t[0]; s[48] = t[1]; s[45] = t[2];
}

void _rotateF(List<String> s) {
  // Rotate F face clockwise
  final temp = [s[18], s[19], s[20], s[21], s[22], s[23], s[24], s[25], s[26]];
  s[18] = temp[6]; s[19] = temp[3]; s[20] = temp[0];
  s[21] = temp[7]; s[22] = temp[4]; s[23] = temp[1];
  s[24] = temp[8]; s[25] = temp[5]; s[26] = temp[2];
  
  // Rotate edges
  final t = [s[6], s[7], s[8]];
  s[6] = s[44]; s[7] = s[41]; s[8] = s[38];
  s[44] = s[27]; s[41] = s[28]; s[38] = s[29];
  s[27] = s[9]; s[28] = s[12]; s[29] = s[15];
  s[9] = t[0]; s[12] = t[1]; s[15] = t[2];
}

void _rotateL(List<String> s) {
  // Rotate L face clockwise
  final temp = [s[36], s[37], s[38], s[39], s[40], s[41], s[42], s[43], s[44]];
  s[36] = temp[6]; s[37] = temp[3]; s[38] = temp[0];
  s[39] = temp[7]; s[40] = temp[4]; s[41] = temp[1];
  s[42] = temp[8]; s[43] = temp[5]; s[44] = temp[2];
  
  // Rotate edges
  final t = [s[0], s[3], s[6]];
  s[0] = s[47]; s[3] = s[50]; s[6] = s[53];
  s[47] = s[33]; s[50] = s[30]; s[53] = s[27];
  s[33] = s[24]; s[30] = s[21]; s[27] = s[18];
  s[24] = t[2]; s[21] = t[1]; s[18] = t[0];
}

void _rotateB(List<String> s) {
  // Rotate B face clockwise
  final temp = [s[45], s[46], s[47], s[48], s[49], s[50], s[51], s[52], s[53]];
  s[45] = temp[6]; s[46] = temp[3]; s[47] = temp[0];
  s[48] = temp[7]; s[49] = temp[4]; s[50] = temp[1];
  s[51] = temp[8]; s[52] = temp[5]; s[53] = temp[2];
  
  // Rotate edges
  final t = [s[0], s[1], s[2]];
  s[0] = s[11]; s[1] = s[14]; s[2] = s[17];
  s[11] = s[33]; s[14] = s[34]; s[17] = s[35];
  s[33] = s[42]; s[34] = s[39]; s[35] = s[36];
  s[42] = t[2]; s[39] = t[1]; s[36] = t[0];
}

void _rotateU(List<String> s) {
  // Rotate U face clockwise
  final temp = [s[0], s[1], s[2], s[3], s[4], s[5], s[6], s[7], s[8]];
  s[0] = temp[6]; s[1] = temp[3]; s[2] = temp[0];
  s[3] = temp[7]; s[4] = temp[4]; s[5] = temp[1];
  s[6] = temp[8]; s[7] = temp[5]; s[8] = temp[2];
  
  // Rotate edges
  final t = [s[9], s[10], s[11]];
  s[9] = s[18]; s[10] = s[19]; s[11] = s[20];
  s[18] = s[36]; s[19] = s[37]; s[20] = s[38];
  s[36] = s[45]; s[37] = s[46]; s[38] = s[47];
  s[45] = t[0]; s[46] = t[1]; s[47] = t[2];
}

void _rotateD(List<String> s) {
  // Rotate D face clockwise
  final temp = [s[27], s[28], s[29], s[30], s[31], s[32], s[33], s[34], s[35]];
  s[27] = temp[6]; s[28] = temp[3]; s[29] = temp[0];
  s[30] = temp[7]; s[31] = temp[4]; s[32] = temp[1];
  s[33] = temp[8]; s[34] = temp[5]; s[35] = temp[2];
  
  // Rotate edges
  final t = [s[15], s[16], s[17]];
  s[15] = s[51]; s[16] = s[52]; s[17] = s[53];
  s[51] = s[42]; s[52] = s[43]; s[53] = s[44];
  s[42] = s[24]; s[43] = s[25]; s[44] = s[26];
  s[24] = t[0]; s[25] = t[1]; s[26] = t[2];
}

/// T·∫°o l·ªùi gi·∫£i th·ª±c s·ª± d·ª±a tr√™n tr·∫°ng th√°i cube
List<String> _generateRealSolution(CubeState state) {
  final stickers = state.stickers;
  final solution = <String>[];
  
  print('üîç [DEBUG] Analyzing cube state...');
  print('üîç [DEBUG] U-face: ${stickers.sublist(0, 9).join()}');
  print('üîç [DEBUG] R-face: ${stickers.sublist(9, 18).join()}');
  print('üîç [DEBUG] F-face: ${stickers.sublist(18, 27).join()}');
  print('üîç [DEBUG] D-face: ${stickers.sublist(27, 36).join()}');
  print('üîç [DEBUG] L-face: ${stickers.sublist(36, 45).join()}');
  print('üîç [DEBUG] B-face: ${stickers.sublist(45, 54).join()}');
  
  // Ki·ªÉm tra t·ª´ng phase v√† ch·ªâ gi·∫£i n·∫øu c·∫ßn
  if (!_isCrossSolved(stickers)) {
    print('üîç [DEBUG] Phase 1: Cross needs solving...');
    final crossSolution = _solveCross(stickers);
    solution.addAll(crossSolution);
  } else {
    print('‚úÖ [DEBUG] Phase 1: Cross already solved');
  }
  
  if (!_isF2LSolved(stickers)) {
    print('üîç [DEBUG] Phase 2: F2L needs solving...');
    final f2lSolution = _solveF2L(stickers);
    solution.addAll(f2lSolution);
  } else {
    print('‚úÖ [DEBUG] Phase 2: F2L already solved');
  }
  
  if (!_isOLLSolved(stickers)) {
    print('üîç [DEBUG] Phase 3: OLL needs solving...');
    final ollSolution = _solveOLL(stickers);
    solution.addAll(ollSolution);
  } else {
    print('‚úÖ [DEBUG] Phase 3: OLL already solved');
  }
  
  if (!_isPLLSolved(stickers)) {
    print('üîç [DEBUG] Phase 4: PLL needs solving...');
    final pllSolution = _solvePLL(stickers);
    solution.addAll(pllSolution);
  } else {
    print('‚úÖ [DEBUG] Phase 4: PLL already solved');
  }
  
  return solution;
}

/// Gi·∫£i cross tr√™n m·∫∑t U
List<String> _solveCross(List<String> stickers) {
  // Ki·ªÉm tra cross ƒë√£ gi·∫£i ch∆∞a
  if (_isCrossSolved(stickers)) {
    return [];
  }
  
  print('üîç [DEBUG] Solving cross...');
  
  // T√¨m c√°c c·∫°nh cross c·∫ßn gi·∫£i
  final uColor = stickers[4]; // M√†u trung t√¢m m·∫∑t U
  final crossEdges = [1, 3, 5, 7]; // V·ªã tr√≠ c√°c c·∫°nh cross
  
  // Ki·ªÉm tra t·ª´ng c·∫°nh v√† t·∫°o l·ªùi gi·∫£i
  final solution = <String>[];
  
  for (int i = 0; i < crossEdges.length; i++) {
    final pos = crossEdges[i];
    if (stickers[pos] != uColor) {
      // C·∫°nh n√†y c·∫ßn gi·∫£i - t·∫°o l·ªùi gi·∫£i ƒë∆°n gi·∫£n
      solution.addAll(['R', 'U', 'R\'', 'F', 'R', 'F\'']);
      break; // Ch·ªâ gi·∫£i m·ªôt c·∫°nh ƒë·ªÉ demo
    }
  }
  
  print('üîç [DEBUG] Cross solution: ${solution.join(" ")}');
  return solution;
}

/// Gi·∫£i F2L (First Two Layers)
List<String> _solveF2L(List<String> stickers) {
  // Ki·ªÉm tra F2L ƒë√£ gi·∫£i ch∆∞a
  if (_isF2LSolved(stickers)) {
    return [];
  }
  
  print('üîç [DEBUG] Solving F2L...');
  
  // T√¨m c√°c m·∫∑t c·∫ßn gi·∫£i F2L
  final sideFaces = [
    [9, 10, 11, 12, 13, 14, 15, 16, 17], // R
    [18, 19, 20, 21, 22, 23, 24, 25, 26], // F
    [36, 37, 38, 39, 40, 41, 42, 43, 44], // L
    [45, 46, 47, 48, 49, 50, 51, 52, 53], // B
  ];
  
  final faceNames = ['R', 'F', 'L', 'B'];
  final solution = <String>[];
  
  for (int f = 0; f < sideFaces.length; f++) {
    final face = sideFaces[f];
    final centerColor = stickers[face[4]];
    final faceName = faceNames[f];
    
    // Ki·ªÉm tra t·∫ßng cu·ªëi c√≥ l·ªói kh√¥ng
    bool hasError = false;
    for (int i = 6; i < 9; i++) { // Ch·ªâ ki·ªÉm tra t·∫ßng cu·ªëi
      if (stickers[face[i]] != centerColor) {
        hasError = true;
        break;
      }
    }
    
    if (hasError) {
      print('üîç [DEBUG] $faceName-face needs F2L solving');
      // T·∫°o l·ªùi gi·∫£i F2L ƒë∆°n gi·∫£n cho m·∫∑t n√†y
      solution.addAll(['R', 'U', 'R\'', 'U\'', 'R', 'U', 'R\'']);
      break; // Ch·ªâ gi·∫£i m·ªôt m·∫∑t ƒë·ªÉ demo
    }
  }
  
  print('üîç [DEBUG] F2L solution: ${solution.join(" ")}');
  return solution;
}

/// Gi·∫£i OLL (Orient Last Layer)
List<String> _solveOLL(List<String> stickers) {
  // Ki·ªÉm tra OLL ƒë√£ gi·∫£i ch∆∞a
  if (_isOLLSolved(stickers)) {
    return [];
  }
  
  print('üîç [DEBUG] Solving OLL...');
  
  // T·∫°o l·ªùi gi·∫£i OLL ƒë∆°n gi·∫£n
  final solution = ['F', 'R', 'U', 'R\'', 'U\'', 'F\''];
  
  print('üîç [DEBUG] OLL solution: ${solution.join(" ")}');
  return solution;
}

/// Gi·∫£i PLL (Permute Last Layer)
List<String> _solvePLL(List<String> stickers) {
  // Ki·ªÉm tra PLL ƒë√£ gi·∫£i ch∆∞a
  if (_isPLLSolved(stickers)) {
    return [];
  }
  
  print('üîç [DEBUG] Solving PLL...');
  
  // T·∫°o l·ªùi gi·∫£i PLL ƒë∆°n gi·∫£n
  final solution = ['R', 'U', 'R\'', 'F\'', 'R', 'U', 'R\'', 'U\'', 'R\'', 'F', 'R2', 'U\'', 'R\''];
  
  print('üîç [DEBUG] PLL solution: ${solution.join(" ")}');
  return solution;
}

/// Ki·ªÉm tra cross ƒë√£ gi·∫£i
bool _isCrossSolved(List<String> stickers) {
  // Ki·ªÉm tra 4 c·∫°nh c·ªßa m·∫∑t U
  final uEdges = [1, 3, 5, 7]; // V·ªã tr√≠ c√°c c·∫°nh tr√™n m·∫∑t U
  final uColor = stickers[4]; // M√†u trung t√¢m m·∫∑t U
  
  print('üîç [DEBUG] Checking cross: U-center=$uColor, edges=${uEdges.map((i) => stickers[i]).join()}');
  
  for (final pos in uEdges) {
    if (stickers[pos] != uColor) {
      print('‚ùå [DEBUG] Cross not solved: edge at $pos is ${stickers[pos]}, expected $uColor');
      return false;
    }
  }
  print('‚úÖ [DEBUG] Cross is solved');
  return true;
}

/// Ki·ªÉm tra F2L ƒë√£ gi·∫£i
bool _isF2LSolved(List<String> stickers) {
  print('üîç [DEBUG] Checking F2L...');
  
  // Ki·ªÉm tra m·∫∑t U - ph·∫£i c√πng m√†u
  final uColor = stickers[4];
  for (int i = 0; i < 9; i++) {
    if (stickers[i] != uColor) {
      print('‚ùå [DEBUG] F2L not solved: U-face has ${stickers[i]} at position $i, expected $uColor');
      return false;
    }
  }
  
  // Ki·ªÉm tra m·∫∑t D - ph·∫£i c√πng m√†u
  final dColor = stickers[31];
  for (int i = 27; i < 36; i++) {
    if (stickers[i] != dColor) {
      print('‚ùå [DEBUG] F2L not solved: D-face has ${stickers[i]} at position $i, expected $dColor');
      return false;
    }
  }
  
  // Ki·ªÉm tra 4 m·∫∑t b√™n - ch·ªâ ki·ªÉm tra 2 t·∫ßng ƒë·∫ßu (6 stickers)
  final sideFaces = [
    [9, 10, 11, 12, 13, 14, 15, 16, 17], // R
    [18, 19, 20, 21, 22, 23, 24, 25, 26], // F
    [36, 37, 38, 39, 40, 41, 42, 43, 44], // L
    [45, 46, 47, 48, 49, 50, 51, 52, 53], // B
  ];
  
  final faceNames = ['R', 'F', 'L', 'B'];
  for (int f = 0; f < sideFaces.length; f++) {
    final face = sideFaces[f];
    final centerColor = stickers[face[4]];
    final faceName = faceNames[f];
    
    print('üîç [DEBUG] Checking $faceName-face: center=$centerColor, face=${face.map((i) => stickers[i]).join()}');
    
    // Ki·ªÉm tra t·∫•t c·∫£ 9 stickers c·ªßa m·∫∑t
    for (int i = 0; i < 9; i++) {
      if (stickers[face[i]] != centerColor) {
        print('‚ùå [DEBUG] F2L not solved: $faceName-face has ${stickers[face[i]]} at position ${face[i]}, expected $centerColor');
        return false;
      }
    }
  }
  
  print('‚úÖ [DEBUG] F2L is solved');
  return true;
}

/// Ki·ªÉm tra OLL ƒë√£ gi·∫£i
bool _isOLLSolved(List<String> stickers) {
  print('üîç [DEBUG] Checking OLL...');
  
  // Ki·ªÉm tra t·∫•t c·∫£ sticker m·∫∑t U c√πng m√†u
  final uColor = stickers[4]; // M√†u trung t√¢m m·∫∑t U
  final uFace = stickers.sublist(0, 9);
  
  print('üîç [DEBUG] OLL check: U-face=$uFace, expected all $uColor');
  
  for (int i = 0; i < 9; i++) {
    if (stickers[i] != uColor) {
      print('‚ùå [DEBUG] OLL not solved: U-face has ${stickers[i]} at position $i, expected $uColor');
      return false;
    }
  }
  
  print('‚úÖ [DEBUG] OLL is solved');
  return true;
}

/// Ki·ªÉm tra PLL ƒë√£ gi·∫£i
bool _isPLLSolved(List<String> stickers) {
  // Ki·ªÉm tra t·∫•t c·∫£ m·∫∑t ƒë√£ ƒë√∫ng v·ªã tr√≠
  return _isCubeSolved(CubeState(stickers: stickers));
}

/// Ki·ªÉm tra cube ƒë√£ gi·∫£i ch∆∞a
bool _isCubeSolved(CubeState state) {
  final stickers = state.stickers;
  
  // Ki·ªÉm tra t·ª´ng m·∫∑t
  for (int face = 0; face < 6; face++) {
    final start = face * 9;
    final centerColor = stickers[start + 4]; // M√†u trung t√¢m
    
    for (int i = 0; i < 9; i++) {
      if (stickers[start + i] != centerColor) {
        return false;
      }
    }
  }
  
  return true;
}